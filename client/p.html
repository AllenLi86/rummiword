<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rummiword - Phaser éŠæˆ²ç•«é¢</title>
  
  <!-- Phaser æ¡†æ¶ -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1a2e;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }

    #game-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>

<body>
  <div id="game-container">
    <!-- è¼‰å…¥ç•«é¢ -->
    <div class="loading-screen" id="loading-screen">
      <div class="loading-content">
        <div class="spinner"></div>
        <h2>ğŸ® è¼‰å…¥ Rummiword</h2>
        <p>æ­£åœ¨åˆå§‹åŒ–éŠæˆ²...</p>
      </div>
    </div>
  </div>

  <script>
    // ========== å…¨å±€è®Šé‡ ==========
    let game = null;
    let gameScene = null;
    
    // éŠæˆ²ç‹€æ…‹
    const gameState = {
      currentPlayer: 0,
      players: [
        { id: 1, name: 'ç©å®¶1', hand: [], isCurrentPlayer: true },
        { id: 2, name: 'ç©å®¶2', hand: [], isCurrentPlayer: false },
        { id: 3, name: 'ç©å®¶3', hand: [], isCurrentPlayer: false },
        { id: 4, name: 'ç©å®¶4', hand: [], isCurrentPlayer: false }
      ],
      board: [],
      tilePool: 98,
      gamePhase: 'playing' // playing, ended
    };

    // å­—æ¯ç£šé…ç½®ï¼ˆåŸºæ–¼ Rummikub Wordï¼‰
    const TILE_CONFIG = {
      'A': { count: 9, points: 1 }, 'B': { count: 2, points: 3 }, 'C': { count: 2, points: 3 },
      'D': { count: 4, points: 2 }, 'E': { count: 12, points: 1 }, 'F': { count: 2, points: 4 },
      'G': { count: 3, points: 2 }, 'H': { count: 2, points: 4 }, 'I': { count: 9, points: 1 },
      'J': { count: 1, points: 8 }, 'K': { count: 1, points: 5 }, 'L': { count: 4, points: 1 },
      'M': { count: 2, points: 3 }, 'N': { count: 6, points: 1 }, 'O': { count: 8, points: 1 },
      'P': { count: 2, points: 3 }, 'Q': { count: 1, points: 10 }, 'R': { count: 6, points: 1 },
      'S': { count: 4, points: 1 }, 'T': { count: 6, points: 1 }, 'U': { count: 4, points: 1 },
      'V': { count: 2, points: 4 }, 'W': { count: 2, points: 4 }, 'X': { count: 1, points: 8 },
      'Y': { count: 2, points: 4 }, 'Z': { count: 1, points: 10 }, 'â˜…': { count: 2, points: 0 }
    };

    // ========== Phaser éŠæˆ²é…ç½® ==========
    function initializeGame() {
      // è¨ˆç®—éŸ¿æ‡‰å¼å°ºå¯¸
      const gameSize = calculateGameSize();
      
      const config = {
        type: Phaser.AUTO,
        width: gameSize.width,
        height: gameSize.height,
        parent: 'game-container',
        backgroundColor: '#0f3460',
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      game = new Phaser.Game(config);
      
      // éš±è—è¼‰å…¥ç•«é¢
      setTimeout(() => {
        document.getElementById('loading-screen').style.opacity = '0';
        setTimeout(() => {
          document.getElementById('loading-screen').style.display = 'none';
        }, 500);
      }, 2000);
    }

    function calculateGameSize() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      
      let width = 1200;
      let height = 800;
      
      if (vw < 768) {
        width = Math.min(vw - 20, 800);
        height = Math.min(vh - 20, 600);
      } else if (vw < 1024) {
        width = Math.min(vw - 40, 1000);
        height = Math.min(vh - 40, 700);
      } else {
        const ratio = Math.min(vw / width, vh / height) * 0.95;
        width = width * ratio;
        height = height * ratio;
      }
      
      return { width: Math.floor(width), height: Math.floor(height) };
    }

    // ========== Phaser å ´æ™¯å‡½æ•¸ ==========
    function preload() {
      console.log('ğŸ“¦ è¼‰å…¥éŠæˆ²è³‡æº');
      gameScene = this;
      
      // å‰µå»ºç£šå¡Šæè³ª
      createTileTextures(this);
      
      // å‰µå»ºæŒ‰éˆ•æè³ª
      createButtonTextures(this);
      
      // è¼‰å…¥é€²åº¦é¡¯ç¤º
      const progressBar = this.add.graphics();
      const progressBox = this.add.graphics();
      progressBox.fillStyle(0x222222);
      progressBox.fillRect(this.cameras.main.width / 2 - 160, this.cameras.main.height / 2 - 25, 320, 50);
      
      this.load.on('progress', (value) => {
        progressBar.clear();
        progressBar.fillStyle(0x00ff88);
        progressBar.fillRect(this.cameras.main.width / 2 - 150, this.cameras.main.height / 2 - 15, 300 * value, 30);
      });
    }

    function create() {
      console.log('ğŸ¨ å‰µå»ºéŠæˆ²å ´æ™¯');
      const scene = this;
      
      // åˆå§‹åŒ–éŠæˆ²æ•¸æ“š
      initializeGameData();
      
      // å‰µå»ºéŠæˆ²å€åŸŸ
      createGameAreas(scene);
      
      // å‰µå»ºUIå…ƒç´ 
      createUIElements(scene);
      
      // å‰µå»ºæ§åˆ¶æŒ‰éˆ•
      createControlButtons(scene);
      
      // å‰µå»ºç©å®¶æ‰‹ç‰Œ
      createPlayerHands(scene);
      
      // è¨­ç½®äº‹ä»¶ç›£è½
      setupEventListeners(scene);
      
      console.log('âœ… éŠæˆ²å ´æ™¯å‰µå»ºå®Œæˆ');
    }

    function update() {
      // éŠæˆ²æ›´æ–°é‚è¼¯
    }

    // ========== æè³ªå‰µå»º ==========
    function createTileTextures(scene) {
      const graphics = scene.add.graphics();

      // æ™®é€šç£šå¡Šæè³ª
      graphics.fillGradientStyle(0xffeaa7, 0xffeaa7, 0xfdcb6e, 0xfdcb6e);
      graphics.fillRoundedRect(0, 0, 60, 60, 8);
      graphics.lineStyle(2, 0xe17055);
      graphics.strokeRoundedRect(1, 1, 58, 58, 8);
      graphics.generateTexture('tile-normal', 60, 60);

      // è¬ç”¨ç£šå¡Šæè³ª
      graphics.clear();
      graphics.fillGradientStyle(0xe0e0e0, 0xe0e0e0, 0xc0c0c0, 0xc0c0c0);
      graphics.fillRoundedRect(0, 0, 60, 60, 8);
      graphics.lineStyle(2, 0x999999);
      graphics.strokeRoundedRect(1, 1, 58, 58, 8);
      graphics.generateTexture('tile-blank', 60, 60);

      // é¸ä¸­æ•ˆæœæè³ª
      graphics.clear();
      graphics.fillStyle(0x007bff, 0.3);
      graphics.fillRoundedRect(0, 0, 64, 64, 8);
      graphics.lineStyle(3, 0x007bff);
      graphics.strokeRoundedRect(2, 2, 60, 60, 8);
      graphics.generateTexture('tile-selected', 64, 64);

      // æ‹–æ‹½é™°å½±æ•ˆæœ
      graphics.clear();
      graphics.fillStyle(0x000000, 0.3);
      graphics.fillRoundedRect(2, 2, 60, 60, 8);
      graphics.generateTexture('tile-shadow', 64, 64);

      graphics.destroy();
    }

    function createButtonTextures(scene) {
      const graphics = scene.add.graphics();
      
      // ä¸»è¦æŒ‰éˆ•
      graphics.fillGradientStyle(0x007bff, 0x007bff, 0x0056b3, 0x0056b3);
      graphics.fillRoundedRect(0, 0, 120, 40, 8);
      graphics.lineStyle(2, 0x0056b3);
      graphics.strokeRoundedRect(1, 1, 118, 38, 8);
      graphics.generateTexture('button-primary', 120, 40);

      // å±éšªæŒ‰éˆ•
      graphics.clear();
      graphics.fillGradientStyle(0xdc3545, 0xdc3545, 0xc82333, 0xc82333);
      graphics.fillRoundedRect(0, 0, 120, 40, 8);
      graphics.lineStyle(2, 0xc82333);
      graphics.strokeRoundedRect(1, 1, 118, 38, 8);
      graphics.generateTexture('button-danger', 120, 40);

      // æˆåŠŸæŒ‰éˆ•
      graphics.clear();
      graphics.fillGradientStyle(0x28a745, 0x28a745, 0x218838, 0x218838);
      graphics.fillRoundedRect(0, 0, 120, 40, 8);
      graphics.lineStyle(2, 0x218838);
      graphics.strokeRoundedRect(1, 1, 118, 38, 8);
      graphics.generateTexture('button-success', 120, 40);

      graphics.destroy();
    }

    // ========== éŠæˆ²å€åŸŸå‰µå»º ==========
    function createGameAreas(scene) {
      const { width, height } = scene.cameras.main;
      
      // èƒŒæ™¯æ¼¸å±¤
      const backgroundGraphics = scene.add.graphics();
      backgroundGraphics.fillGradientStyle(0x0f3460, 0x16213e, 0x0e2954, 0x533483);
      backgroundGraphics.fillRect(0, 0, width, height);
      
      // ä¸»è¦æ”¾ç‰Œå€åŸŸï¼ˆä¸­å¤®ï¼‰
      const boardWidth = Math.min(width * 0.7, 800);
      const boardHeight = Math.min(height * 0.4, 300);
      const boardX = width / 2;
      const boardY = height * 0.35;
      
      scene.boardArea = scene.add.graphics();
      scene.boardArea.fillStyle(0x2c5aa0, 0.3);
      scene.boardArea.fillRoundedRect(
        boardX - boardWidth/2, 
        boardY - boardHeight/2, 
        boardWidth, 
        boardHeight, 
        15
      );
      scene.boardArea.lineStyle(3, 0x4682b4);
      scene.boardArea.strokeRoundedRect(
        boardX - boardWidth/2, 
        boardY - boardY/2, 
        boardWidth, 
        boardHeight, 
        15
      );
      
      // æ”¾ç‰Œå€åŸŸæ¨™é¡Œ
      scene.add.text(boardX, boardY - boardHeight/2 - 30, 'ğŸ¯ å…¬å…±æ”¾ç‰Œå€åŸŸ', {
        fontSize: width < 768 ? '18px' : '24px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      // å­˜å‚¨å€åŸŸè³‡è¨Š
      scene.boardZone = {
        x: boardX - boardWidth/2,
        y: boardY - boardHeight/2,
        width: boardWidth,
        height: boardHeight,
        centerX: boardX,
        centerY: boardY
      };
      
      // å‰µå»ºç©å®¶æ‰‹ç‰Œå€åŸŸ
      createHandAreas(scene);
    }

    function createHandAreas(scene) {
      const { width, height } = scene.cameras.main;
      
      // ç•¶å‰ç©å®¶æ‰‹ç‰Œå€åŸŸï¼ˆåº•éƒ¨ï¼‰
      const handWidth = Math.min(width * 0.9, 900);
      const handHeight = 100;
      const handX = width / 2;
      const handY = height - handHeight/2 - 20;
      
      scene.handArea = scene.add.graphics();
      scene.handArea.fillStyle(0x1e3a8a, 0.4);
      scene.handArea.fillRoundedRect(
        handX - handWidth/2, 
        handY - handHeight/2, 
        handWidth, 
        handHeight, 
        10
      );
      scene.handArea.lineStyle(2, 0x3b82f6);
      scene.handArea.strokeRoundedRect(
        handX - handWidth/2, 
        handY - handHeight/2, 
        handWidth, 
        handHeight, 
        10
      );
      
      // æ‰‹ç‰Œæ¨™é¡Œ
      scene.add.text(handX - handWidth/2 + 20, handY - handHeight/2 - 25, 'ğŸ¯ æˆ‘çš„æ‰‹ç‰Œ', {
        fontSize: width < 768 ? '14px' : '18px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0, 0.5);
      
      // å­˜å‚¨æ‰‹ç‰Œå€åŸŸè³‡è¨Š
      scene.handZone = {
        x: handX - handWidth/2,
        y: handY - handHeight/2,
        width: handWidth,
        height: handHeight,
        centerX: handX,
        centerY: handY
      };

      // å…¶ä»–ç©å®¶çš„æ‰‹ç‰Œé è¦½å€åŸŸ
      createOtherPlayersAreas(scene);
    }

    function createOtherPlayersAreas(scene) {
      const { width, height } = scene.cameras.main;
      const isMobile = width < 768;
      
      // å…¶ä»–ç©å®¶ä½ç½®ï¼šä¸Šæ–¹ã€å·¦å´ã€å³å´
      const otherPlayersPositions = [
        { x: width / 2, y: 60, anchor: 'top', name: 'ç©å®¶2' },
        { x: 80, y: height / 2, anchor: 'left', name: 'ç©å®¶3' },
        { x: width - 80, y: height / 2, anchor: 'right', name: 'ç©å®¶4' }
      ];
      
      scene.otherPlayersAreas = [];
      
      otherPlayersPositions.forEach((pos, index) => {
        // æ ¹æ“šä½ç½®èª¿æ•´æ‰‹ç‰Œé è¦½å¤§å°
        let cardWidth = isMobile ? 200 : 300;
        let cardHeight = isMobile ? 30 : 40;
        
        if (pos.anchor === 'left' || pos.anchor === 'right') {
          cardWidth = isMobile ? 30 : 40;
          cardHeight = isMobile ? 150 : 200;
        }
        
        // ç©å®¶æ‰‹ç‰ŒèƒŒæ™¯
        const playerArea = scene.add.graphics();
        playerArea.fillStyle(0x1f2937, 0.6);
        playerArea.fillRoundedRect(
          pos.x - cardWidth/2, 
          pos.y - cardHeight/2, 
          cardWidth, 
          cardHeight, 
          8
        );
        playerArea.lineStyle(1, 0x6b7280);
        playerArea.strokeRoundedRect(
          pos.x - cardWidth/2, 
          pos.y - cardHeight/2, 
          cardWidth, 
          cardHeight, 
          8
        );
        
        // ç©å®¶åç¨±
        const nameY = pos.anchor === 'top' ? pos.y - cardHeight/2 - 20 : 
                     pos.anchor === 'left' ? pos.y - cardHeight/2 - 20 :
                     pos.y - cardHeight/2 - 20;
        
        const playerName = scene.add.text(pos.x, nameY, pos.name, {
          fontSize: isMobile ? '12px' : '14px',
          fontFamily: 'Arial',
          color: '#e5e7eb',
          fontStyle: 'bold'
        }).setOrigin(0.5);
        
        // æ‰‹ç‰Œæ•¸é‡é¡¯ç¤º
        const tileCount = scene.add.text(pos.x, pos.y, '7', {
          fontSize: isMobile ? '16px' : '20px',
          fontFamily: 'Arial',
          color: '#ffffff',
          fontStyle: 'bold'
        }).setOrigin(0.5);
        
        scene.otherPlayersAreas.push({
          area: playerArea,
          name: playerName,
          count: tileCount,
          position: pos
        });
      });
    }

    // ========== UI å…ƒç´ å‰µå»º ==========
    function createUIElements(scene) {
      const { width, height } = scene.cameras.main;
      const isMobile = width < 768;
      
      // éŠæˆ²æ¨™é¡Œ
      scene.add.text(width / 2, 30, 'ğŸ® Rummiword', {
        fontSize: isMobile ? '20px' : '28px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      // éŠæˆ²è³‡è¨Šé¢æ¿
      const infoPanel = scene.add.graphics();
      infoPanel.fillStyle(0x1f2937, 0.8);
      infoPanel.fillRoundedRect(width - 200, 10, 180, 120, 8);
      infoPanel.lineStyle(1, 0x4b5563);
      infoPanel.strokeRoundedRect(width - 200, 10, 180, 120, 8);
      
      // éŠæˆ²è³‡è¨Šæ–‡å­—
      scene.tilePoolText = scene.add.text(width - 190, 25, 'ğŸ² å‰©é¤˜ç£šå¡Š: 98', {
        fontSize: '14px',
        fontFamily: 'Arial',
        color: '#ffffff'
      });
      
      scene.currentPlayerText = scene.add.text(width - 190, 45, 'ğŸ‘¤ ç•¶å‰ç©å®¶: ç©å®¶1', {
        fontSize: '14px',
        fontFamily: 'Arial',
        color: '#10b981'
      });
      
      scene.turnCountText = scene.add.text(width - 190, 65, 'ğŸ”„ å›åˆæ•¸: 1', {
        fontSize: '14px',
        fontFamily: 'Arial',
        color: '#f59e0b'
      });
      
      scene.handCountText = scene.add.text(width - 190, 85, 'ğŸ¯ æ‰‹ç‰Œ: 7å¼µ', {
        fontSize: '14px',
        fontFamily: 'Arial',
        color: '#3b82f6'
      });
      
      scene.scoreText = scene.add.text(width - 190, 105, 'â­ åˆ†æ•¸: 0', {
        fontSize: '14px',
        fontFamily: 'Arial',
        color: '#ef4444'
      });
    }

    function createControlButtons(scene) {
      const { width, height } = scene.cameras.main;
      const isMobile = width < 768;
      
      // æŒ‰éˆ•ä½ç½®è¨ˆç®—
      const buttonY = height - 30;
      const buttonSpacing = isMobile ? 130 : 140;
      const startX = width / 2 - buttonSpacing;
      
      // æŠ½ç£šæŒ‰éˆ•
      scene.drawTileBtn = scene.add.image(startX, buttonY, 'button-primary')
        .setInteractive({ cursor: 'pointer' })
        .setScale(isMobile ? 0.8 : 1);
      
      const drawBtnText = scene.add.text(startX, buttonY, 'ğŸ² æŠ½ç£š', {
        fontSize: isMobile ? '12px' : '14px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      // çµæŸå›åˆæŒ‰éˆ•
      scene.endTurnBtn = scene.add.image(startX + buttonSpacing, buttonY, 'button-danger')
        .setInteractive({ cursor: 'pointer' })
        .setScale(isMobile ? 0.8 : 1);
      
      const endTurnText = scene.add.text(startX + buttonSpacing, buttonY, 'â­ï¸ çµæŸå›åˆ', {
        fontSize: isMobile ? '12px' : '14px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      // æª¢æŸ¥å–®è©æŒ‰éˆ•
      scene.checkWordBtn = scene.add.image(startX + buttonSpacing * 2, buttonY, 'button-success')
        .setInteractive({ cursor: 'pointer' })
        .setScale(isMobile ? 0.8 : 1);
      
      const checkWordText = scene.add.text(startX + buttonSpacing * 2, buttonY, 'âœ… æª¢æŸ¥', {
        fontSize: isMobile ? '12px' : '14px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      
      // æŒ‰éˆ•äº‹ä»¶
      scene.drawTileBtn.on('pointerdown', () => drawTile(scene));
      scene.endTurnBtn.on('pointerdown', () => endTurn(scene));
      scene.checkWordBtn.on('pointerdown', () => checkWords(scene));
      
      // æ‡¸åœæ•ˆæœ
      [scene.drawTileBtn, scene.endTurnBtn, scene.checkWordBtn].forEach(btn => {
        btn.on('pointerover', () => btn.setScale((isMobile ? 0.8 : 1) * 1.05));
        btn.on('pointerout', () => btn.setScale(isMobile ? 0.8 : 1));
      });
    }

    // ========== å­—æ¯ç£šå‰µå»ºå’Œç®¡ç† ==========
    function createPlayerHands(scene) {
      scene.playerTiles = [];
      scene.selectedTiles = [];
      
      // ç‚ºç•¶å‰ç©å®¶å‰µå»ºåˆå§‹æ‰‹ç‰Œ
      const startingHand = generateRandomHand(7);
      gameState.players[0].hand = startingHand;
      
      renderPlayerHand(scene);
    }

    function generateRandomHand(count) {
      const hand = [];
      const letters = Object.keys(TILE_CONFIG);
      
      for (let i = 0; i < count; i++) {
        const randomLetter = letters[Math.floor(Math.random() * letters.length)];
        const config = TILE_CONFIG[randomLetter];
        
        hand.push({
          id: `tile_${Date.now()}_${i}`,
          letter: randomLetter,
          points: config.points,
          isBlank: randomLetter === 'â˜…'
        });
      }
      
      return hand;
    }

    function renderPlayerHand(scene) {
      // æ¸…é™¤ç¾æœ‰ç£šå¡Š
      scene.playerTiles.forEach(tile => tile.destroy());
      scene.playerTiles = [];
      
      const hand = gameState.players[0].hand;
      if (hand.length === 0) return;
      
      const { centerX, centerY, width } = scene.handZone;
      const tileSpacing = Math.min((width - 40) / hand.length, 70);
      const startX = centerX - ((hand.length - 1) * tileSpacing) / 2;
      
      hand.forEach((tileData, index) => {
        const tile = createTileSprite(scene, startX + index * tileSpacing, centerY, tileData);
        scene.playerTiles.push(tile);
      });
      
      // æ›´æ–°æ‰‹ç‰Œæ•¸é‡é¡¯ç¤º
      scene.handCountText.setText(`ğŸ¯ æ‰‹ç‰Œ: ${hand.length}å¼µ`);
    }

    function createTileSprite(scene, x, y, tileData) {
      const isBlank = tileData.isBlank;
      const texture = isBlank ? 'tile-blank' : 'tile-normal';
      
      // å‰µå»ºç£šå¡Šå®¹å™¨
      const tileContainer = scene.add.container(x, y);
      
      // èƒŒæ™¯
      const background = scene.add.image(0, 0, texture);
      tileContainer.add(background);
      
      // å­—æ¯
      const letterText = scene.add.text(0, -5, tileData.letter, {
        fontSize: isBlank ? '20px' : '24px',
        fontFamily: 'Arial',
        color: isBlank ? '#666666' : '#2d3748',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      tileContainer.add(letterText);
      
      // åˆ†æ•¸
      if (!isBlank) {
        const pointsText = scene.add.text(18, 18, tileData.points.toString(), {
          fontSize: '12px',
          fontFamily: 'Arial',
          color: '#4a5568'
        }).setOrigin(0.5);
        tileContainer.add(pointsText);
      }
      
      // è¨­ç½®äº’å‹•
      tileContainer.setSize(60, 60);
      tileContainer.setInteractive({ cursor: 'pointer', draggable: true });
      
      // å­˜å„²ç£šå¡Šæ•¸æ“š
      tileContainer.tileData = tileData;
      tileContainer.isSelected = false;
      tileContainer.originalX = x;
      tileContainer.originalY = y;
      
      // é»æ“Šé¸ä¸­
      tileContainer.on('pointerdown', () => toggleTileSelection(scene, tileContainer));
      
      // æ‹–æ‹½äº‹ä»¶
      tileContainer.on('dragstart', () => startTileDrag(scene, tileContainer));
      tileContainer.on('drag', (pointer, dragX, dragY) => dragTile(scene, tileContainer, dragX, dragY));
      tileContainer.on('dragend', () => endTileDrag(scene, tileContainer));
      
      return tileContainer;
    }

    // ========== ç£šå¡Šäº’å‹•é‚è¼¯ ==========
    function toggleTileSelection(scene, tile) {
      if (tile.isSelected) {
        deselectTile(scene, tile);
      } else {
        selectTile(scene, tile);
      }
    }

    function selectTile(scene, tile) {
      if (tile.isSelected) return;
      
      tile.isSelected = true;
      scene.selectedTiles.push(tile);
      
      // è¦–è¦ºæ•ˆæœ
      const selectedEffect = scene.add.image(0, 0, 'tile-selected');
      tile.addAt(selectedEffect, 0);
      tile.selectedEffect = selectedEffect;
      
      // å‘ä¸Šç§»å‹•
      scene.tweens.add({
        targets: tile,
        y: tile.originalY - 15,
        duration: 200,
        ease: 'Power2'
      });
      
      console.log('é¸ä¸­ç£šå¡Š:', tile.tileData.letter);
    }

    function deselectTile(scene, tile) {
      if (!tile.isSelected) return;
      
      tile.isSelected = false;
      const index = scene.selectedTiles.indexOf(tile);
      if (index > -1) {
        scene.selectedTiles.splice(index, 1);
      }
      
      // ç§»é™¤è¦–è¦ºæ•ˆæœ
      if (tile.selectedEffect) {
        tile.selectedEffect.destroy();
        tile.selectedEffect = null;
      }
      
      // å›åˆ°åŸä½
      scene.tweens.add({
        targets: tile,
        y: tile.originalY,
        duration: 200,
        ease: 'Power2'
      });
      
      console.log('å–æ¶ˆé¸ä¸­ç£šå¡Š:', tile.tileData.letter);
    }

    function startTileDrag(scene, tile) {
      tile.setScale(1.1);
      tile.setDepth(1000);
      tile.setAlpha(0.8);
      
      // å‰µå»ºæ‹–æ‹½é™°å½±
      if (!tile.dragShadow) {
        tile.dragShadow = scene.add.image(tile.originalX, tile.originalY, 'tile-shadow');
        tile.dragShadow.setDepth(1);
      }
    }

    function dragTile(scene, tile, dragX, dragY) {
      tile.x = dragX;
      tile.y = dragY;
    }

    function endTileDrag(scene, tile) {
      tile.setScale(1);
      tile.setDepth(10);
      tile.setAlpha(1);
      
      // ç§»é™¤é™°å½±
      if (tile.dragShadow) {
        tile.dragShadow.destroy();
        tile.dragShadow = null;
      }
      
      // æª¢æŸ¥æ˜¯å¦æ‹–æ‹½åˆ°æ”¾ç‰Œå€åŸŸ
      if (isInBoardArea(tile.x, tile.y, scene.boardZone)) {
        placeTileOnBoard(scene, tile);
      } else {
        // å›åˆ°åŸä½
        scene.tweens.add({
          targets: tile,
          x: tile.originalX,
          y: tile.originalY,
          duration: 300,
          ease: 'Power2'
        });
      }
    }

    function isInBoardArea(x, y, boardZone) {
      return x >= boardZone.x && 
             x <= boardZone.x + boardZone.width && 
             y >= boardZone.y && 
             y <= boardZone.y + boardZone.height;
    }

    function placeTileOnBoard(scene, tile) {
      console.log('æ”¾ç½®ç£šå¡Šåˆ°æ£‹ç›¤:', tile.tileData.letter);
      
      // æ‰¾åˆ°æ£‹ç›¤ä¸Šåˆé©çš„ä½ç½®
      const boardPosition = findBoardPosition(scene, tile);
      
      // ç§»å‹•åˆ°æ£‹ç›¤ä½ç½®
      scene.tweens.add({
        targets: tile,
        x: boardPosition.x,
        y: boardPosition.y,
        duration: 300,
        ease: 'Power2',
        onComplete: () => {
          // æ›´æ–°ç£šå¡Šç‹€æ…‹
          tile.isOnBoard = true;
          tile.boardX = boardPosition.x;
          tile.boardY = boardPosition.y;
          
          // å¾æ‰‹ç‰Œä¸­ç§»é™¤
          removeFromHand(scene, tile);
          
          // æ·»åŠ åˆ°æ£‹ç›¤
          addToBoard(scene, tile);
        }
      });
    }

    function findBoardPosition(scene, tile) {
      const { centerX, centerY } = scene.boardZone;
      
      // ç°¡å–®çš„ç¶²æ ¼ä½ˆå±€ï¼ˆå¯ä»¥å¾ŒçºŒæ”¹é€²ï¼‰
      const boardTilesCount = scene.boardTiles ? scene.boardTiles.length : 0;
      const spacing = 70;
      const tilesPerRow = 8;
      
      const row = Math.floor(boardTilesCount / tilesPerRow);
      const col = boardTilesCount % tilesPerRow;
      
      const startX = centerX - (tilesPerRow - 1) * spacing / 2;
      const startY = centerY - 50;
      
      return {
        x: startX + col * spacing,
        y: startY + row * spacing
      };
    }

    function removeFromHand(scene, tile) {
      // å¾ç©å®¶æ‰‹ç‰Œæ•¸æ“šä¸­ç§»é™¤
      const hand = gameState.players[0].hand;
      const index = hand.findIndex(t => t.id === tile.tileData.id);
      if (index > -1) {
        hand.splice(index, 1);
      }
      
      // å¾å ´æ™¯ç£šå¡Šæ•¸çµ„ä¸­ç§»é™¤
      const tileIndex = scene.playerTiles.indexOf(tile);
      if (tileIndex > -1) {
        scene.playerTiles.splice(tileIndex, 1);
      }
      
      // é‡æ–°æ’åˆ—æ‰‹ç‰Œ
      rearrangeHand(scene);
    }

    function addToBoard(scene, tile) {
      if (!scene.boardTiles) {
        scene.boardTiles = [];
      }
      
      scene.boardTiles.push(tile);
      gameState.board.push(tile.tileData);
      
      console.log('ç£šå¡Šå·²æ·»åŠ åˆ°æ£‹ç›¤ï¼Œç•¶å‰æ£‹ç›¤ç£šå¡Šæ•¸:', scene.boardTiles.length);
    }

    function rearrangeHand(scene) {
      const hand = gameState.players[0].hand;
      const { centerX, centerY, width } = scene.handZone;
      
      if (hand.length === 0) return;
      
      const tileSpacing = Math.min((width - 40) / hand.length, 70);
      const startX = centerX - ((hand.length - 1) * tileSpacing) / 2;
      
      scene.playerTiles.forEach((tile, index) => {
        const newX = startX + index * tileSpacing;
        tile.originalX = newX;
        
        scene.tweens.add({
          targets: tile,
          x: newX,
          duration: 300,
          ease: 'Power2'
        });
      });
      
      // æ›´æ–°æ‰‹ç‰Œæ•¸é‡é¡¯ç¤º
      scene.handCountText.setText(`ğŸ¯ æ‰‹ç‰Œ: ${hand.length}å¼µ`);
    }

    // ========== éŠæˆ²æ§åˆ¶å‡½æ•¸ ==========
    function drawTile(scene) {
      console.log('ğŸ² ç©å®¶æŠ½ç£š');
      
      if (gameState.tilePool <= 0) {
        showMessage(scene, 'ç£šå¡Šæ± å·²ç©ºï¼', 'warning');
        return;
      }
      
      // ç”Ÿæˆæ–°ç£šå¡Š
      const newTile = generateRandomTile();
      gameState.players[0].hand.push(newTile);
      gameState.tilePool--;
      
      // å‰µå»ºæ–°ç£šå¡Šè¦–è¦ºæ•ˆæœ
      const hand = gameState.players[0].hand;
      const { centerX, centerY, width } = scene.handZone;
      const tileSpacing = Math.min((width - 40) / hand.length, 70);
      const newX = centerX + ((hand.length - 1) * tileSpacing) / 2;
      
      const tile = createTileSprite(scene, newX, centerY - 100, newTile);
      scene.playerTiles.push(tile);
      
      // å‹•ç•«æ•ˆæœ
      scene.tweens.add({
        targets: tile,
        y: centerY,
        duration: 500,
        ease: 'Bounce.easeOut'
      });
      
      // é‡æ–°æ’åˆ—æ‰‹ç‰Œ
      setTimeout(() => rearrangeHand(scene), 500);
      
      // æ›´æ–°UI
      scene.tilePoolText.setText(`ğŸ² å‰©é¤˜ç£šå¡Š: ${gameState.tilePool}`);
      
      showMessage(scene, `æŠ½åˆ°: ${newTile.letter}`, 'success');
    }

    function generateRandomTile() {
      const letters = Object.keys(TILE_CONFIG);
      const randomLetter = letters[Math.floor(Math.random() * letters.length)];
      const config = TILE_CONFIG[randomLetter];
      
      return {
        id: `tile_${Date.now()}_${Math.random()}`,
        letter: randomLetter,
        points: config.points,
        isBlank: randomLetter === 'â˜…'
      };
    }

    function endTurn(scene) {
      console.log('â­ï¸ çµæŸå›åˆ');
      
      // æ¸…é™¤é¸ä¸­ç‹€æ…‹
      scene.selectedTiles.forEach(tile => deselectTile(scene, tile));
      
      // åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶
      gameState.currentPlayer = (gameState.currentPlayer + 1) % 4;
      const currentPlayerName = gameState.players[gameState.currentPlayer].name;
      
      scene.currentPlayerText.setText(`ğŸ‘¤ ç•¶å‰ç©å®¶: ${currentPlayerName}`);
      
      // å¦‚æœè¼ªåˆ°ç©å®¶1ï¼Œå¢åŠ å›åˆæ•¸
      if (gameState.currentPlayer === 0) {
        const currentTurn = parseInt(scene.turnCountText.text.split(': ')[1]) + 1;
        scene.turnCountText.setText(`ğŸ”„ å›åˆæ•¸: ${currentTurn}`);
      }
      
      showMessage(scene, `è¼ªåˆ° ${currentPlayerName}`, 'info');
    }

    function checkWords(scene) {
      console.log('âœ… æª¢æŸ¥å–®è©');
      
      if (scene.boardTiles.length === 0) {
        showMessage(scene, 'æ£‹ç›¤ä¸Šæ²’æœ‰ç£šå¡Šï¼', 'warning');
        return;
      }
      
      // æ”¶é›†æ£‹ç›¤ä¸Šçš„å­—æ¯
      const letters = scene.boardTiles.map(tile => tile.tileData.letter).join('');
      
      // ç°¡å–®çš„å–®è©æª¢æŸ¥ï¼ˆå¯¦éš›éŠæˆ²ä¸­æœƒé€£æ¥å­—å…¸APIï¼‰
      const isValidWord = checkWordValidity(letters);
      
      if (isValidWord) {
        const score = calculateWordScore(scene.boardTiles);
        showMessage(scene, `æœ‰æ•ˆå–®è©: ${letters} (+${score}åˆ†)`, 'success');
        
        // æ›´æ–°åˆ†æ•¸
        const currentScore = parseInt(scene.scoreText.text.split(': ')[1]);
        scene.scoreText.setText(`â­ åˆ†æ•¸: ${currentScore + score}`);
      } else {
        showMessage(scene, `ç„¡æ•ˆå–®è©: ${letters}`, 'error');
      }
    }

    function checkWordValidity(word) {
      // ç°¡åŒ–çš„å–®è©æª¢æŸ¥ï¼šé•·åº¦å¤§æ–¼2å°±è¦–ç‚ºæœ‰æ•ˆ
      // å¯¦éš›å¯¦ç¾æœƒé€£æ¥å­—å…¸API
      const validWords = ['CAT', 'DOG', 'WORD', 'GAME', 'TEST', 'PLAY', 'TILE', 'CARD'];
      return word.length >= 3 || validWords.includes(word.toUpperCase());
    }

    function calculateWordScore(tiles) {
      return tiles.reduce((score, tile) => score + tile.tileData.points, 0);
    }

    // ========== è¨Šæ¯ç³»çµ± ==========
    function showMessage(scene, text, type = 'info') {
      const { width } = scene.cameras.main;
      
      // ç§»é™¤èˆŠè¨Šæ¯
      if (scene.currentMessage) {
        scene.currentMessage.destroy();
      }
      
      // è¨Šæ¯é¡è‰²
      const colors = {
        success: 0x10b981,
        error: 0xef4444,
        warning: 0xf59e0b,
        info: 0x3b82f6
      };
      
      const color = colors[type] || colors.info;
      
      // å‰µå»ºè¨Šæ¯èƒŒæ™¯
      const messageGraphics = scene.add.graphics();
      messageGraphics.fillStyle(color, 0.9);
      messageGraphics.fillRoundedRect(width/2 - 150, 150, 300, 60, 10);
      messageGraphics.lineStyle(2, color);
      messageGraphics.strokeRoundedRect(width/2 - 150, 150, 300, 60, 10);
      
      // å‰µå»ºè¨Šæ¯æ–‡å­—
      const messageText = scene.add.text(width/2, 180, text, {
        fontSize: '16px',
        fontFamily: 'Arial',
        color: '#ffffff',
        fontStyle: 'bold',
        align: 'center',
        wordWrap: { width: 280 }
      }).setOrigin(0.5);
      
      // çµ„åˆè¨Šæ¯
      scene.currentMessage = scene.add.container(0, 0, [messageGraphics, messageText]);
      scene.currentMessage.setDepth(2000);
      
      // æ·¡å…¥å‹•ç•«
      scene.currentMessage.setAlpha(0);
      scene.tweens.add({
        targets: scene.currentMessage,
        alpha: 1,
        duration: 300,
        ease: 'Power2'
      });
      
      // è‡ªå‹•æ¶ˆå¤±
      scene.time.delayedCall(3000, () => {
        if (scene.currentMessage) {
          scene.tweens.add({
            targets: scene.currentMessage,
            alpha: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => {
              if (scene.currentMessage) {
                scene.currentMessage.destroy();
                scene.currentMessage = null;
              }
            }
          });
        }
      });
      
      console.log(`è¨Šæ¯ [${type}]: ${text}`);
    }

    // ========== äº‹ä»¶ç›£è½ ==========
    function setupEventListeners(scene) {
      // éµç›¤äº‹ä»¶
      const cursors = scene.input.keyboard.createCursorKeys();
      
      // å¿«æ·éµ
      scene.input.keyboard.on('keydown-D', () => drawTile(scene));
      scene.input.keyboard.on('keydown-E', () => endTurn(scene));
      scene.input.keyboard.on('keydown-C', () => checkWords(scene));
      scene.input.keyboard.on('keydown-ESC', () => {
        // æ¸…é™¤æ‰€æœ‰é¸ä¸­
        scene.selectedTiles.forEach(tile => deselectTile(scene, tile));
      });
      
      console.log('âŒ¨ï¸ å¿«æ·éµè¨­ç½®å®Œæˆ: D(æŠ½ç£š), E(çµæŸå›åˆ), C(æª¢æŸ¥), ESC(æ¸…é™¤é¸ä¸­)');
    }

    // ========== éŠæˆ²æ•¸æ“šåˆå§‹åŒ– ==========
    function initializeGameData() {
      console.log('ğŸ® åˆå§‹åŒ–éŠæˆ²æ•¸æ“š');
      
      // è¨­ç½®ç©å®¶åç¨±ï¼ˆå¯¦éš›éŠæˆ²ä¸­å¾æœå‹™å™¨ç²å–ï¼‰
      gameState.players = [
        { id: 1, name: 'ä½ ', hand: [], isCurrentPlayer: true },
        { id: 2, name: 'ç©å®¶2', hand: [], isCurrentPlayer: false },
        { id: 3, name: 'ç©å®¶3', hand: [], isCurrentPlayer: false },
        { id: 4, name: 'ç©å®¶4', hand: [], isCurrentPlayer: false }
      ];
      
      console.log('âœ… éŠæˆ²æ•¸æ“šåˆå§‹åŒ–å®Œæˆ');
    }

    // ========== éŸ¿æ‡‰å¼è™•ç† ==========
    window.addEventListener('resize', () => {
      if (game) {
        setTimeout(() => {
          const newSize = calculateGameSize();
          game.scale.resize(newSize.width, newSize.height);
          console.log(`ğŸ“ è¦–çª—èª¿æ•´ï¼Œæ–°éŠæˆ²å°ºå¯¸: ${newSize.width}x${newSize.height}`);
        }, 100);
      }
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (game) {
          const newSize = calculateGameSize();
          game.scale.resize(newSize.width, newSize.height);
          console.log('ğŸ”„ è¢å¹•æ–¹å‘è®ŠåŒ–ï¼Œé‡æ–°è¨ˆç®—éŠæˆ²å°ºå¯¸');
        }
      }, 500);
    });

    // ========== åˆå§‹åŒ–éŠæˆ² ==========
    document.addEventListener('DOMContentLoaded', () => {
      console.log('ğŸš€ é–‹å§‹è¼‰å…¥ Rummiword Phaser éŠæˆ²');
      initializeGame();
    });

    // ========== èª¿è©¦å‡½æ•¸ ==========
    window.debugGame = () => {
      console.log('ğŸ”§ éŠæˆ²ç‹€æ…‹èª¿è©¦è³‡è¨Š:');
      console.log('éŠæˆ²ç‹€æ…‹:', gameState);
      console.log('å ´æ™¯ç‰©ä»¶:', gameScene);
      console.log('é¸ä¸­ç£šå¡Š:', gameScene?.selectedTiles?.length || 0);
      console.log('æ£‹ç›¤ç£šå¡Š:', gameScene?.boardTiles?.length || 0);
    };

    console.log('âœ… Rummiword Phaser éŠæˆ²è…³æœ¬è¼‰å…¥å®Œæˆ');
    console.log('ğŸ“‹ å¿«æ·éµèªªæ˜: D(æŠ½ç£š), E(çµæŸå›åˆ), C(æª¢æŸ¥å–®è©), ESC(æ¸…é™¤é¸ä¸­)');
    console.log('ğŸ”§ èª¿è©¦å‘½ä»¤: debugGame() - æŸ¥çœ‹éŠæˆ²ç‹€æ…‹');
  </script>
</body>
</html>